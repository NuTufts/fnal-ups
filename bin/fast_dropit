#!/bin/sh


# fast_dropit -- shell function to remove items from a path-style variable
#     string	-- string to match against path components, items that match
#		   are dropped
#     path	-- path to edit
#     char	-- input and output delimiter, defaults to :

fast_dropit() {

    d_substring=$1
    # defaults
    if [ $# -lt 3 ] 
    then 
        d_d=":"		# delimiter
    else
        d_d="$3"		# delimiter
    fi

    if [ $# -lt 2 ] 
    then
        d_p="$PATH"
    else
        d_p="$2"
    fi

    d_a="[^$d_d]*"
    d_e="[^$d_d]*"

    if [ "$d_substring" = "/bin" -o "$d_substring" = "" ]
    then
	echo "fast dropit: skipping drop of '$d_substring' -- too dangerous" >&2
	continue
    fi

    # escape wildcards, etc. in substring (e.g. SunOS+5)
    d_substringp="`echo $d_substring |
	sed -e 's|[^a-zA-Z_0-9()]|\\\\&|g'`"

    # Now we actually remove the substring occurances from the string.
    # We splice delimiters on both ends first (we'lltake them back off
    # 	when we're done.)
    # we double all the delimiters, (so we match adjacent components)
    # remove the matches
    # un-double the delimiters
    # and clean the extras off the ends.
    # It looks like a lot, but it's only one sed call...

    d_match="${d_d}${d_a}${d_substringp}${d_e}${d_d}"
    d_p="`echo $d_p | 
	sed -e \"s|.*|${d_d}&${d_d}|\" \
	    -e \"s|${d_d}|${d_d}${d_d}|g\" \
	    -e \"s|${d_match}||g\" \
	    -e \"s|${d_d}${d_d}|${d_d}|g\" \
	    -e \"s|${d_d}\(.*\)${d_d}|\1|\"`"

    echo $d_p
     
}

fast_dropit "$@"
